/**
*Ferran Cantari√±o i Iglesias - 173705
*Marc Rabat Pla - 172808
*/

/**
*Ex 1. A simple parser (output: yes/no)
*1a) What is the language generated by the following grammar?
*/

%Answer: The language generated by this grammar is one which can generate arithmetic operations (with its terms between parentheses if desired) with plus(+) %and product(*) operators with the terminals characters a, b, c & d. (Whereas not very relevant, it is also possible to generate uniquely the terminal %characters)

% Examples of the descripted language: 
% ( a + b * c ) * ( c * a ) + b + d
% ( c * b ) + a*c 
% a
% b

/**
*1b) Top-Down Parser
*/

%Facts of the grammar

rule( n(e) , [n(g),n(e1)]).
rule( n(e1) , [t(+),n(g),n(e1)]).
rule( n(e1) , [ ]).
rule( n(g) , [n(f),n(g1)] ).
rule( n(g1) , [t(*),n(f),n(g1)] ).
rule( n(g1) , [ ] ).
rule( n(f) , [t('('),n(e),t(')')] ).
rule( n(f) , [t(a)] ).
rule( n(f) , [t(b)] ).
rule( n(f) , [t(c)] ).
rule( n(f) , [t(d)] ).

%Parser
parse([],[]).
parse(Input,[n(X)|Stack]):- rule(n(X),R), append(R,Stack,NStack), parse(Input,NStack).
parse([t(W)|NStack],[t(W)|R2]):- parse(NStack,R2).

%Functioning tests:
%parse([t(+),t(a),t(b)],[n(e)]). Outputs: False
%parse([t(a),t(+),t(b)],[n(e)]). Outputs: True
%parse([t('('),t(a),t(+),t(b),t(')'),t(*),t(c)],[n(e)]). Outputs: True
%For the Examples:
%( a + b * c ) * ( c * a ) + b + d
%parse([t('('),t(a),t(+),t(b),t(*), t(c), t(')'),t(*),t('('),t(c), t(*),t(a),t(')'), t(+),t(b), t(+),t(d)],[n(e)]). Outputs: True
% ( c * b ) + a*c
%parse([t('('), t(c),t(*),t(b), t(')'), t(+),t(a),t(*),t(c)],[n(e)]). Outputs: True
%a
%parse([t(a)],[n(e)]). Outputs: True


/**
*Ex 2. A simple automata.
*/

%Declaration of the automata
initial(1).
final(4).
arc(1,2,j).
arc(2,3,a).
arc(3,4,!).
arc(2,1,a).

recognize(I):- initial(Node), r(Node,I).

%Base
r(Node,[]):- final(Node).

%Recursion Part
r(Node,[X|R]):- arc(Node,I,X), r(I,R).

generate(X):- recognize(X).

%recognize([j,a,j,a,!]). Outputs: True
%recognize([j,a,j!]). Outputs: False